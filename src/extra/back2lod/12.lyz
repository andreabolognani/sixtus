start#page
tab#iv
	title#'Sti dati – <code>03/12</code> 2012
	Ed eccomi con lo script pronto, in attesa di un buco in cui spostarmi con
	l'intero <em>ambaradan</em>, a preparare <code>$programmone</code> che
	raccolga i dati al posto mio. Perché io di sicuro non voglio stare lì a
	lanciare <code>&gt;9000</code> script.

	Quindi, eccomi qui. Sto riconvertendo il vecchio programma, che avevo
	cominciato… eh… uhm… era il <code>31 luglio 2012</code> (tante grazie a
	<code>git log</code> per averlo datato). Con esso devo raccogliere i
	risultati delle mie query, nel modo più rapido possibile.

	Ma accade che il povero oscilloscopio non sia esattamente la macchina più
	potente del mondo, né la più recente; se gli domando <code>1000pt</code> lui
	riesce anche a darmeli, ma impiega un po' di tempo a convertirli tutti in
	stringhe.
	begin#inside
		speak@gods#Non è un problema@immagino@la conversione posso farla io, no?
	end#inside
	E invece. Se chiedo dati <em>grezzi</em>, il bastardo mi fornisce
	<code>2011 byte</code> che rappresentano <code>[¹]</code> l'header e
	<code>[²]</code> uno stream di <code>float16</code>.
	r#E per convertirli mi sto dissanguando.
	sec#
	title#'Sti &Gamma;&alpha;&zeta;&zeta;&omega; di dati! – <code>04/12</code>
	Beninteso, il problema ora è stato completamente risolto. Ma non vi dico le
	bestemmie che mi sono scaturite alla scoperta dei motivi, e la fatica per
	evitare che uscissero dalla bocca e spaventassero i miei colleghi. Dunque.
	br#
	L'oscilloscopio <code>dso7032a</code> – che d'ora in poi sarà
	<em class="wrong">affettuosamente</em> noto come <em>il $Pupone</em> – è una
	buona macchina, ma il suo comportamento e il suo manuale non vanno
	perfettamente d'accordo. In particolare, le dichiarazioni del manuale
	riguardo i comandi e il loro risultato contengono un'infinità (numerabile)
	di omissioni che conducono lentamente il <em>GODS</em> alla follia. Ma
	d'altronde <em>«Il mattino ha l'oro in bocca»</em>
	p#<em>«Il mattino ha l'oro in bocca»</em>
	p#<em>«Il mattino ha l'oro in bocca»</em>
	p#<em>«Il mattino ha l'oro in bocca»</em>
	p#<em>«Il mattino ha l'oro in bocca»</em>
	p#<em>«Il mattino ha l'oro in bocca»</em>
	p#<em>«Il mattino ha l'oro in bocca»</em>
	p#<em>«Il mattino ha l'oro in bocca»</em>
	p#<em>«Il mattino ha l'oro in bocca»</em>
	p#<em>«Il mattino ha l'oro in bocca»</em>
	r#Ma sto divagando.
	br#
	p#Il punto è che l'output non è quello che dovrebbe essere: se chiedo i dati
	scritti (<code>:WAV:FORMat ASCii</code>) l'oscilloscopi impiega un po'
	troppo tempo a rispondere… non voglio che si perda via, considerato che gli
	esperimenti potrebbero durare giornate intere… quindi vedo di chiedergli i
	dati grezzi.

	Le alternative sono <code>BYTE</code> e <code>WORD</code>. Il manuale mi
	dice che il primo formato serve per ricevere dati in <code>8bit</code> e il
	secondo, ovviamente, per <code>16bit</code>. Voglio perdere meno
	informazione possibile avere dati buoni, quindi scelgo la seconda. Ma come
	faccio – io che ho <em>Tanngrisnir</em> con un processore a
	<code>64bit</code> a leggere e gestire dei <code>float16</code>? Diventando
	scemo. Applico una semplice <code>union</code> del <code>C</code> (la
	soluzione più semplice, come <em class="dacav">Simgi</em> confermerà
	sicuramente), ci infilo due caratteri ed estraggo un valore. Un valore
	brutto e sbagliato.

	Chiedo aiuto e <em class="jazz">Jazz</em> mi fa notare che il
	<code>float16</code> è distribuito in modo completamente diverso dal
	<code>float32</code> che io dovrei usare… apro le specifiche dei formati e
	scopro che
	begin#half@left
		stitle@right#Float16
		begin#ul
			p#<code>1bit</code> per il segno
			p#<code>6bit</code> per l'esponente (rispetto a <code>15</code>)
			p#<code>9bit</code> per la mantissa
		end#ul
	end#half
	begin#half@right
		stitle#Float32
		begin#ul
			p#<code>1bit</code> per il segno
			p#<code>8bit</code> per l'esponente (rispetto a <code>127</code>)
			p#<code>23bit</code> per la mantissa
		end#ul
	end#half
	per cui applico un semplice
	begin#outside
		<code>((a & 0x8000) << 16) | (((a & 0x7c00) >> 5 + 112) << 8) | ((a &
		0x3ff) << 12)</code>
	end#outside
	e divento felice. O forse no. I numeri sembrano buoni, ma sono comunque
	diversi da quelli indicati dal <em>$Pupone</em> e la forma complessiva
	dell'onda non è troppo simile.
	
	Giro, cerco, provo, faccio cose. Chiedo agli esempi (che sono tutti in
	<code>Basic</code>, raccolti in una delle appendici in fondo al manualone).
	Qui scopro una cosa spaventosa: nell'esempio per la raccolta dati con
	<code>:WAV:DATA?</code>, <em>mooooooooooooolto</em> sotto le chiamate
	interessanti e soltanto dopo aver sbrodolato ogni parametro del preambolo,
	ecco il codice che infila i dati in un buffer; noto che quel codice copia
	semplicemente i dati che gli arrivano, uno alla volta nel caso degli
	<code>8bit</code> e due nel caso dei <code>16bit</code>.

	Incredulo come mai nella mia vita vado a controllare e scopro che, anche
	altrove, tutti si aspettavano che i dati fossero <code>uint16</code>. Ogni
	dato trasmesso è l'offset verticale del punto rispetto all'ampiezza
	verticale della finestra acquisita. <strong>&lt;[DEI]!!! &amp; [PORCHI]!!! &amp;
	[MADONNE]!!!&gt;</strong>
	br#
	Poi.

	Noto che quando <code>GNUplot</code> mi
	mostra i dati, tutto sembra scaglionati in una manciata di possibili valori
	(sull'asse verticale); l'atroce dubbio mi colpisce: non sarà mica che la
	significatività dei due byte è storta? Controllo il manuale, che mi
	consiglia di chiedere <code>:WAVeform:BYTeorder?</code> per scoprirlo:
	<code>MSBF</code>, il primo è anche il più significativo; ma per scrupolo
	controllo anche nel codice, inverto la raccolta e verifico; l'onda assume
	magicamente la forma giusta.

	speak@gods#<em>$Pupone</em>, perché menti?
	esclamo, ma lui finge di non capire. Trattengo a stento altre
	<strong>&lt;[&delta;&epsilon;&iota;] [&pi;&omicron;&rho;&gamma;&eta;&iota;]
	[&mu;&alpha;&delta;&omicron;&nu;&nu;&epsilon;]&gt;</strong> e vado avanti.
	Dopo una mezza giornata, scopro che quei <code>2011byte</code> che io ricevo
	non sono (come dice il manuale) composti di
	<code>header(11)+dati(2*1000)</code>, bensì (come dice uno degli esempi)
	<code>header(10)+dati(2*1000)+\n</code>. Lo stream di <code>byte</code> con
	i dati grezzi di cui conosco già esattamente la dimensione va a capo, quindi
	l'ultimo <code>byte</code> non è significativo come pensavo, ma è
	completamente inutile.
	
	La significatività sui <code>16bit</code> ora ha un senso, e posso leggere i
	dati che voglio. Ma se solo ripenso ai due giorni buttati per questo…
tab#v
	title#Cambio! Hole Of Doom – <code>05/12</code>
	Ho un ufficio!
	sec#
	“Annunciate a <em>Sgaggio</em> le mie nuove possibilità di lettura, io &amp;
	lui si è passati immediatamente a discutere degli esperimenti da effettuare.
	Incredibili prospettive per il futuro negli occhi di <em>Sgaggio</em>, ma
	dopo avergli io ricordato che la <em>$Cotoletta</em> non funziona, siamo
	tornati entrambi alla realtà.

	“Se l'oscilloscopio non ha due canali da confrontare, la valenza scientifica
	dei dati raccolta è praticamente nulla. Occorre quindi un altro segnale da
	associare a quello dello <em>$Scatolotto</em>.
	
	“Tristemente, l'unica alternativa è il <em>MasterClock</em>; s'è quindi
	proceduto alla ricerca d'una maniera per avvicinare i due dispositivi a
	sufficienza perché entrambi fossero raggiungibili dal <em>$Pupone</em>.”
	sec#
	A quel punto, <em>Sgaggio</em> s'illumina e mi porta di sopra: tra il suo
	ufficio e quello di fronte c'è un corridoio stretto stretto con una porta
	che io ho sempre visto chiusa. Pare che questo buco – noto come <em>Ex
	(Paperino) Tomasi</em> o meglio Ufficio <code>SS01</code> – sia inutilizzato
	da <code>&gt;9000</code> anni e lo si potrebbe anche chiedere in prestito
	con il permesso del capo dipartimento del <em>DISI</em>, un uomo il cui
	titolo è <em>Full Professor</em>.
	
	Tempo due mezze giornate, eccomi con le chiavi in mano e il permesso –
	richiesto da <em>Sgaggio</em> e controfirmato dal <em>Full Professor</em> –
	di restare in facoltà fuori orario (giorno &amp; notte, giorni feriali &amp;
	festivi). Si parte dunque per sistemare il “laboratorio”.
	sec#
	begin#mini@right
		foto#Extra/Creazione.jpg
	end#mini
	Eravamo io &amp; <em>Sgaggio</em>, più i volontari <em
	class="mitch">Mitch</em> &amp; <em class="jazz">Jazz</em> (e il
	<em>cagionevole</em> <em class="war">War</em> che non stava bene);
	l'obiettivo era di spostare tutto l'allestimento dall'<code>Aula5</code> al
	<em>Buco</em>; la prima cosa da fare (quella che premeva di più a
	<em>Sgaggio</em>) era il cavo dell'antenna <code>GPS</code>.
	
	Per questo, ci siamo portati sulla terrazza sopra il <code>CISCA</code> per
	staccare il cavo, l'abbiamo calato e poi ci siamo fermati a pensare… siamo
	poi andati sotto sotto sotto il laboratorio di elettronica a chiedere
	“<em>una scala importante</em>” per salire sopra la tettoia.

	Prendi la scala, portala su, aprila, appoggiala, reggila mentre
	<em>Sgaggio</em> sale &amp; lancia il cavo, poi io me ne salgo di sopra,
	apro la finestra e sporgendomi afferro il cavo che <em>Sgaggio</em> mi
	allunga.
	sec#
	In seguito, vengo abbandonato da tutti (perché hanno anche i cazzi loro da
	fare) e proseguo spostando tutto nel <em>Buco</em>: le due
	<em>Freescale</em>, il <em>$Pupone</em>, lo switch <em>Hirschmann</em> e lo
	<em>$Scatolotto</em>. Il <em>MasterClock</em> me l'ha portato
	<em>Sgaggio</em>.

	Ed eccomi, padrone del mio posticino, <em>al freddo &amp; al gelo</em> per
	via della finestra aperta (per far passare il cavo).
	clear#right
	sec#br
	title#Coordinate &amp; riferimenti – <code>07/12</code>
	Poi si passa ad un altro problema: passare da un sistema di coordinate
	all'altro.

	Ancora una volta, il manuale è estremamente nebuloso; per ciascuno dei
	parametri coinvolti indica soltanto una descrizione che espande il nome; per
	l'intero preambolo (che contiene tutti i parametri) indica in una figura la
	posizione e la funzione di ogni parametro. E ancora una volta soltanto gli
	esempi in fondo al manuale indicano esattamente come fare.

	I dati hanno un range verticale di <code>256</code> valori oppure
	<code>65536</code>, dipendentemente dal numero di bit richiesti. Da questi
	dati bisogna sottrarre il <em>riferimento verticale</em>
	<code>YREFerence</code>, che sarebbe il centro verticale della finestra
	campionata (per ciascun canale), che sarebbe <code>128</code> oppure
	<code>32768</code>. Poi il valore va moltiplicato per il <em>passo
	verticale</em> <code>YINCRement</code>, che sarebbe l'altezza di un singolo
	scalino. Infine, al valore va aggiunta l'<em>origine</em>
	<code>YORigin</code>, che sarebbe la traslazione verticale del valore
	campionato.

	E così si passa dai dati inviati ai dati effettivi, che posso
	tranquillamente disegnare con <code>GNUPlot</code>.	Come poi si debba
	raccogliere la differenza in fase tra le due onde, boh.
tab#vi
	Alcuni allegri compagni (<em>Katia</em>, il <em class="dacav">Dacav</em> e
	la <em>Silvia</em>) vennero un bel dì a trovarmi qui
	all'<em>HoleOfDoom</em>. Nel vedere il movimento, <em>Sgaggio</em>
	s'avvicinò a controllare.

	Dopo averci (lui) raccontato che una volta gli era capitato di partecipare
	ad un <em>box party</em> a casa di qualcuno, o forse su un treno, notò una
	lucina rossa sul <em>MasterClock</em> e mi si fermò il cuore.
	br#
	Ma ho scoperto, dopo essermi ripreso dall'infarto, che quella lucina non si
	occupa affatto della porta <code>eth_PTP 192.168.122.130</code>, ma di tutte
	le altre <code>eth_0~4 2:192.168.122.102</code>, lol. È quindi perfettamente
	normale che rimanga rossa.

	Poi mi sono messo a compilare il programmino per <em>Freescale</em>… cerca
	cerca cerca la versione giusta delle toolchain, poi un
	begin#outside
		<code>export
		CC=/opt/buildroot-2012.12/output/host/usr/bin/powerpc-linux-gcc</code>
	end#outside
	per linkare il compilatore, poi <code>Make</code> fa la sua magia ed io mi
	ritrovo con l'aggeggio funzionante al primo colpo.
	sec#
	Ho fatto due conti: se parto venerdì sera e torno lunedì mattina, più o
	meno, ho <code>3 giorni = 72h = 4320' = 259200s</code> di esperimento da
	lasciar andare. Ciascuna <em>Freescale</em> che ho a disposizione mi lascia
	circa <code>60MB</code> di spazio a disposizione, che vuol dire all'incirca
	spazio per <code>2300</code> file da <code>26K</code> ciascuno (1000 righe
	e 2000 numeri).

	Quindi, se i miei conti sono corretti, io devo raccogliere <code>2300
	sample</code> in <code>259200s</code>, campionando una volta ogni
	<code>113'</code>. Che non va affatto bene, mi si perde ogni validità.
	Pertanto, applico un paio di idee:
	begin#ul
		i campionamenti devono essere effettuati piuttosto vicini
		(<code>~1Hz</code>) per calcolare la <em>Varianza di Allan</em>, ma;

		diversi esperimenti potrebbero essere più sparsi, quindi potrei farne
		tanti ma piccini;
	end#ul
	Quindi lancio
	begin#outside
		<code>@SHARP@!/bin/bash</code>
		p#<code>for i in `seq 38`; do</code>
		p#<code>&nbsp;&nbsp;printf "%02d" $i | xargs acquire -n60 -f</code>
		p#<code>&nbsp;&nbsp;printf "%02d Done" $i</code>
		p#<code>&nbsp;&nbsp;sleep 6800</code>
		p#<code>done</code>
	end#outside
	Poi, per trasferirli,
	begin#outside
		<code>tar -cf - &lt;path&gt; | ssh -C
		lyznardh@192.168.122.15 'cd &lt;path&gt; -xf -'</code>
	end#outside
	Tutti i dati sono stati raccolti.
	sec#
	title#Dropbear senza password – <code>17/12</code> 2012
	L'idea sarebbe stata di utilizzare la memoria di entrambe le schede, una per
	fare il lavoro e tenere metà della roba, l'altra per tenere l'altra metà.
	Uno scriptino opportuno avrebbe dovuto attivarsi periodicamente e mandare
	una certa finestra di dati compressi sull'altra scheda, per poi cancellarli
	dalla memoria di questa.

	Ma per farlo occorre che io infili la password ad ogni iterazione, oppure
	che i due host si fidino automaticamente l'uno dell'altro. Per farlo basta
	aprire la sessione SSH aggingendo un file per le credenziali e tutto
	dovrebbe funzionare.

	Ma. Ma per questo serve che la chiave pubblica di un host sia fisicamente
	presente nella memoria dell'altro come chiave affidabile &amp; autorizzata.
	Quindi bisogna mettercela; la si mette in
	<code>~/.ssh/authorized_keys</code>. Per mettercela, bisogna estrarla; la si
	estrae con <code>dropbearkey -y -f /etc/dropbear/dropbear_rsa_host_key |
	grep ssh-rsa > somekey</code> e la si concatena alle altre. (Per questioni
	di sicurezza, ovviamente, è bene che questo passaggio avvenga su un canale
	sicuro).
	br#
	Lanciati <code>biggerscript 38 60 1500</code> &amp; <code>lighter.sh 1500
	38</code> con grandi speranze.
	sec#
	title#Togliere dalla memoria – <code>18/12</code>
	Lo script <code>lighter.sh</code> non funziona a dovere,
	<em>mpc8313erdb-first</em> dispone soltanto della sua prima finestra,
	<em>mpc8313erdb-second</em> invece le ha praticamente tutte ed è piena (ma
	risponde).

	E poi un sacco di yadda.

	Montare un disco USB sulla Freescale per avere più memoria e meno problemi è
	di per sé un problema, perché il kernel manca del supporto per EXT4, USB,
	SCSI e molta altra yadda.

	make linux-menuconfig → file system → DOS/FAT/NT Filesystem → VFAT (W95)
										→ Nativa Language Support → (
											iso8859-1 default
											codepage 437 us/canada
											NLS iso8859-1 latin 1
										)
	br#
	Altro <strong>&lt;[PROBLEMA]&gt;</strong>: sembra che scrivere su
	<code>Flash/USB</code> sia un po' lentino, e il processo di campionamento ne
	risente… dividerò la cosa in due in modo che l'acquisizione sia effettuata
	direttamente in memoria (<code>/tmp/</code>) e
	successivamente/parallelamente traferita su chiave.
tab#vii
	title#L'intruso – <code>19/12</code>
	Oggi, dopo aver superato l'ultima lezione di <em>Zunino</em> ed essermi
	preparato emotivamente a consegnare l'ultimo assignment per
	<em>Computational Complexity</em> e dopo aver pranzato, me ne sono tornato
	in laboratorio… ed ecco che ci trovo dentro <em>Paperino</em>, il tizio il
	cui nome è (quasi) attaccato alla porta.

	Doveva fare cose su uno dei server presenti in questo stanzino, ed è venuto
	a farlo di persona. Ne ho approfittato per andare a stamparmi il testo
	dell'assignment.
	sec#
	title#La memoria <code>FLASH</code> – <code>19/12</code>
	Ero tanto contento di poter utilizzare una chiavetta per tenere tutto il
	log, vero? E invece… arrivo e vedo che l'oscilloscopio ha terminato. Ma poi
	ripiglia. E poi si ferma. E ricomincia…

	Mi vengono dei bei dubbi… se fosse che la scrittura su chiave USB rallenti
	l'intero processo, devo assolutamente dividere la raccolta (che posso fare
	in memoria) dal salvataggio permanente (ossia spostare dalla memoria alla
	chiave, che posso fare con calma).

	Intendo comunque raccogliere un tot di dati, prima. Ne ho circa
	<code>9100</code>, e volendo aspettare fino a <code>10000</code> ho lanciato
	un
	begin#outside
		<code>&gt;$ sleep 900 && mplayer ~/music/psyco.mp3</code>
	end#outside
	che mi avverta.
	r#Per via del rallentamento, non ha funzionato esattamente…
	br#
	Prima di partire per casa, ho lanciato un'acquisizione di
	<code>(167×300) = 50100Sa</code> assieme ad un altro script che svuota la
	memoria e riempie la chiave. Intanto, sto pensando di spostare la traduzione
	delle coordinate offline, e di acquisire soltanto dati grezzi, per
	risparmiare tempo &amp; spazio.
tab#viii
	title#Dati grezzi, traduzione ed estrazioni – <code>20~22/12</code>
	Estrarre i dati grezzi è semplice. Tradurli è abbastanza semplice. Fare in
	modo che la <em>Freescale</em> li metta su chiavetta, invece, no. A quanto
	pare, ogni tanto fallisco nel farmi capire dalla scheda: due esperimenti
	notturni su tre sono scomparsi, e non ho idea del perché…

	Ma ho sistemato anche questa. Tra ieri e oggi…

	Ora (al <code>22/12</code>) è il caso – mentre piango per essere qui nel
	buco anche di sabato – di introdurre le coordinate nella traduzione. Dalle
	mie ultime osservazioni, infatti, non sono esattamente stabili come speravo.
	br#
	Ed ecco, ora ho un applicazione che acquisisce i dati dall'oscilloscopio,
	uno script che sposta i dati su memoria Flash, un applicazione che applica
	le coordinate ai dati grezzi e uno script che mi plotta le immagini.

	<em>«Dovrebbe essere tutto a posto, adesso»</em>
	r#Ecco, l'ho detto.
stop#page
start#side
	stitle@right#Dicembre 2012
	begin#ul
		p#tid#'Sti dati@ – <code>03~04/12</code>#iv
	end#ul
	stitle#Hole Of Doom
	begin#ul
		p#tid#Le coordinate morbide@ – <code>05~07/12</code>#v
		p#tid#Gli esperimenti@ – <code>12~14/12</code>#vi
		p#tid#L'intruso / memoria FLASH@ – <code>19/12</code>#vii
		p#tid#Dati grezzi e altre cose – <code>20~22</code>#viii
	end#ul
stop#side
